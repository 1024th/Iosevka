$$include '../meta/macros.ptl'

import [Cv AnyCv CvDecompose RightDependentLink RightDependentTrigger] from"../support/gr.mjs"

extern Map
extern Set

define look-around null

define [FeatureName tag] : tag + '_cvss'
define [SsLookupName tag]  : 'lookup_ss_' + tag
define [CvLookupName tag]  : 'lookup_cv_' + tag
define [CvSpecificLookupName tag rank]  : 'lookup_cv_' + tag + '_' + rank
define [CvDecomposeLookupName tag]  : 'lookup_cv_decompose_' + tag

class CvLookupManager
	public [new table tag feature] : begin
		set this.table table
		set this.tag tag
		set this.feature feature

		set this.decompositionLookups {}

		set this.substitutionLookups {}
		set this.altrenatesLookup null
		set this.singleSubstLookups {}

	public [addDecompositionLookup lookup] : begin
		this.decompositionLookups.push lookup
		this.feature.addLookup lookup

	public [alternateSubst] : begin
		if this.altrenatesLookup : return this.altrenatesLookup

		define lookupName : 'lookup_cv_2_alternates_' + this.tag
		define lookup : this.table.pickLookup lookupName {.type 'gsub_alternate' .substitutions {.}}

		this.feature.addLookup lookup
		this.substitutionLookups.push lookup
		set this.altrenatesLookup lookup
		return lookup

	public [singleSubst rank] : begin
		if this.singleSubstLookups.(rank) : return this.singleSubstLookups.(rank)

		define lookupName : 'lookup_cv_1_single_' + this.tag + '_' + rank
		define lookup : this.table.pickLookup lookupName {.type 'gsub_single' .substitutions {.}}

		this.feature.addLookup lookup
		this.substitutionLookups.push lookup
		set this.singleSubstLookups.(rank) lookup
		return lookup

	public [linkDeps] : begin
		foreach a [items-of this.decompositionLookups] : begin
			foreach b [items-of this.substitutionLookups] : begin
				this.table.setDependency a b

		for [local i 1] (i < this.substitutionLookups.length) [inc i]
			this.table.setDependency this.substitutionLookups.(i - 1) this.substitutionLookups.(i)

export : define [buildCVSS gsub para glyphStore] : begin
	local rec : gsub.beginBlock

	local cvs : new Map

	do "Initialize CV feature atlas"
		foreach {name prime} para.variants.primes : if prime.tag : begin
			define feature : gsub.addCommonFeature : gsub.createFeature prime.tag
			local cvLookupManager : new CvLookupManager gsub prime.tag feature
			cvs.set prime.tag cvLookupManager

	do "Build decomposition lookups"
		local decompositions : new Map
		foreach { gn glyph } [glyphStore.namedEntries] : if [CvDecompose.get glyph] : do
			local decomp : object
				parts : CvDecompose.get glyph
				influences : new Set
			decompositions.set gn decomp

			foreach part [items-of decomp.parts] : begin
				local gPart : glyphStore.queryByName part
				if gPart : foreach [gr : items-of : AnyCv.query gPart] : begin
					if gr.tag : decomp.influences.add gr.tag

		foreach { gn decomp } decompositions : if decomp.influences.size : do
			define lookupName : CvDecomposeLookupName : [[Array.from decomp.influences].sort].join '/'
			define lookup : gsub.pickLookup lookupName {.type 'gsub_multiple' .substitutions {.}}
			set lookup.substitutions.(gn) decomp.parts

			foreach cvTag decomp.influences : [cvs.get cvTag].addDecompositionLookup lookup

	do "cvxx"
		local cvGrs {}
		foreach {name prime} para.variants.primes : foreach {vn variant} prime.variants : begin
			if (prime.tag && variant.rank) : cvGrs.push : Cv prime.tag variant.rank
		cvGrs.sort Cv.compare

		foreach gr [items-of cvGrs] : begin
			local cvAlt : [cvs.get gr.tag].alternateSubst
			foreach {gn glyph} [glyphStore.namedEntries] : if [not : CvDecompose.get glyph] : begin
				local subst : gr.get glyph
				if (subst && subst != gn) : begin
					if [not cvAlt.substitutions.(gn)] : set cvAlt.substitutions.(gn) { }
					set cvAlt.substitutions.(gn).(gr.rank - 1) : glyphStore.ensureExists subst

	do "ssxx" : foreach {name composition} para.variants.composites : if composition.tag : begin
		define feature : gsub.addCommonFeature : gsub.createFeature composition.tag

		define decomp : composition.decompose para para.variants.selectorTree
		local ssGrs {}
		foreach { prime pv } [items-of decomp] : if (pv.tag && pv.rank) : begin
			ssGrs.push : Cv pv.tag pv.rank
			foreach lookup [items-of [cvs.get pv.tag].decompositionLookups] : begin
				feature.addLookup lookup
		ssGrs.sort Cv.compare

		foreach gr [items-of ssGrs] : begin
			local cvSingle : [cvs.get gr.tag].singleSubst gr.rank
			feature.addLookup cvSingle
			foreach {gn glyph} [glyphStore.namedEntries] : if [not : CvDecompose.get glyph] : begin
				local subst : gr.get glyph
				if (subst && subst != gn) : begin
					set cvSingle.substitutions.(gn) : glyphStore.ensureExists subst

	do "Cleanup and link dependency"
		foreach cv [cvs.values] : begin
			local st cv.altrenatesLookup.substitutions
			foreach { k v } [pairs-of st] : foreach idx [range 0 v.length] : if [not v.(idx)]
				set v.(idx) k

			cv.linkDeps

	gsub.endBlock rec

define [objectIsNotEmpty obj] : obj && [Object.keys obj].length
